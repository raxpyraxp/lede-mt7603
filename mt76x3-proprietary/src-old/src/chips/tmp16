/*
 ***************************************************************************
 * Ralink Tech Inc.
 * 4F, No. 2 Technology 5th Rd.
 * Science-based Industrial Park
 * Hsin-chu, Taiwan, R.O.C.
 *
 * (c) Copyright 2002-2004, Ralink Technology, Inc.
 *
 * All rights reserved. Ralink's source code is an unpublished work and the
 * use of a copyright notice does not imply otherwise. This source code
 * contains confidential trade secret material of Ralink Tech. Any attemp
 * or participation in deciphering, decoding, reverse engineering or in any
 * way altering the source code is stricitly prohibited, unless the prior
 * written consent of Ralink Technology, Inc. is obtained.
 ***************************************************************************

	Module Name:
	rt6592.c

	Abstract:
	Specific funcitons and configurations for RT6590

	Revision History:
	Who         When          What
	--------    ----------    ----------------------------------------------
*/

#ifdef RT65xx

#include	"rt_config.h"


UCHAR RT6590_EeBuffer[EEPROM_SIZE] = {
	0x83, 0x38, 0x01, 0x00, 0x00, 0x0c, 0x43, 0x28, 0x83, 0x00, 0x83, 0x28, 0x14, 0x18, 0xff, 0xff,
	0xff, 0xff, 0x83, 0x28, 0x14, 0x18, 0x00, 0x00, 0x01, 0x00, 0x6a, 0xff, 0x00, 0x02, 0xff, 0xff,
	0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0x00, 0x0c, 0x43, 0x28, 0x83, 0x01, 0x00, 0x0c,
	0x43, 0x28, 0x83, 0x02, 0x33, 0x0a, 0xec, 0x00, 0x33, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
	0xff, 0xff, 0x20, 0x01, 0x55, 0x77, 0xa8, 0xaa, 0x8c, 0x88, 0xff, 0xff, 0x0a, 0x08, 0x08, 0x06,
	0x00, 0x00, 0x00, 0xff, 0x00, 0x00, 0x00, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
	0x06, 0x06, 0x06, 0x06, 0x06, 0x06, 0x06, 0x06, 0x06, 0x06, 0x06, 0x06, 0x06, 0x06, 0x05, 0x05,
	0x05, 0x05, 0x05, 0x05, 0x05, 0x05, 0x05, 0x05, 0x05, 0x05, 0x05, 0x05, 0x06, 0x06, 0x06, 0x06,
	0x06, 0x06, 0x06, 0x06, 0x06, 0x06, 0x06, 0x06, 0x06, 0x06, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
	0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0x06, 0x06, 0x06, 0x06, 0x06, 0x06, 0x06, 0x06, 0x06, 0x06,
	0x06, 0x06, 0x06, 0x06, 0x06, 0x06, 0x06, 0x06, 0x06, 0x06, 0x06, 0x06, 0x06, 0x06, 0x06, 0x06,
	0x06, 0x06, 0x06, 0x06, 0x06, 0x06, 0x06, 0x06, 0x06, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
	0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0x06, 0x06, 0x06, 0x06, 0x06, 0x06,
	0x06, 0x06, 0x06, 0x06, 0x06, 0x06, 0x06, 0x06, 0x06, 0x06, 0x06, 0x06, 0x06, 0x06, 0x06, 0x06,
	0x06, 0x06, 0x06, 0x06, 0x06, 0x06, 0x06, 0x06, 0x06, 0x06, 0x06, 0x06, 0x06, 0xff, 0xff, 0xff,
	0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0x06, 0x06,
	0x06, 0x06, 0x06, 0x06, 0x06, 0x06, 0x06, 0x06, 0x06, 0x06, 0x06, 0x06, 0x06, 0x06, 0x06, 0x06,
	0x06, 0x06, 0x06, 0x06, 0x06, 0x06, 0x06, 0x06, 0x06, 0x06, 0x06, 0x06, 0x06, 0x06, 0x06, 0x06,
	0x06, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
	0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
	0x66, 0x66, 0xcc, 0xaa, 0x88, 0x66, 0xcc, 0xaa, 0x88, 0x66, 0xcc, 0xaa, 0x88, 0x66, 0xcc, 0xaa,
	0x88, 0x66, 0xcc, 0xaa, 0x88, 0x66, 0xcc, 0xaa, 0x88, 0x66, 0xaa, 0xaa, 0x88, 0x66, 0xaa, 0xaa,
	0x88, 0x66, 0xaa, 0xaa, 0x88, 0x66, 0xcc, 0xaa, 0x88, 0x66, 0xcc, 0xaa, 0x88, 0x66, 0xcc, 0xaa,
	0x88, 0x66, 0xcc, 0xaa, 0x88, 0x66, 0xaa, 0xaa, 0x88, 0x66, 0xaa, 0xaa, 0x88, 0x66, 0xaa, 0xaa,
	0x88, 0x66, 0xaa, 0xaa, 0x88, 0x66, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
	0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
	0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
	0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
	0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
	0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
	0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
	0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
	} ;


#define MT7650_EFUSE_CTRL	0x0024
static RTMP_REG_PAIR	RT6590_MACRegTable[] = {
	{PBF_SYS_CTRL,		0x80c00},
	{PBF_CFG,			0x1f},
	{FCE_CTRL,			0x1},
	{AMPDU_MAX_LEN_20M1S,	0xAA842211},
	{TX_SW_CFG0,			0x604},	/* rising time gap */
// TODO: following register patch from windows
	{TX_SW_CFG1,		0x0},
	{TX_SW_CFG2,		0x0},
// TODO: ----patch end
// TODO: shiang-6590, check what tx report will send to us when following default value set as 2
	{0xa44,					0x0}, /* disable Tx info report */
// TODO: shiang-6590, following regiser used to patch for bbp hang issue, will make the RIFS rx failed!
	{TXOP_HLDR_ET,			0x3},
#if defined(CONFIG_TSO_SUPPORT) || defined(CONFIG_CSO_SUPPORT)
	{0x80c,				0x8},
#endif /* defined(CONFIG_TSO_SUPPORT) || defined(CONFIG_CSO_SUPPORT) */


	/*
		TC6008_TOP_MAC_reg_initial_value_20120426.xlsx 
	*/
	{AUX_CLK_CFG, 0x0},  /* Disable aux_clk_en */
	{BB_PA_MODE_CFG0, 0x010055FF},
	{BB_PA_MODE_CFG1, 0x00550055},
	{RF_PA_MODE_CFG0, 0x010055FF},
	{RF_PA_MODE_CFG1, 0x00550055},

	{TX_ALC_CFG_0, 0x5},
	{TX0_RF_GAIN_CORR, 0x00190000}, /* +2.5dB */
	{TX0_BB_GAIN_ATTEN, 0x00000000}, /* set BBP atten gain = 0 */
	{TX_ALC_VGA3, 0x0005000C}, /*  whenALC.RF[3:2] = 3, +3dB */
	{TX_PWR_CFG_0, 0x30303030},
	{TX_PWR_CFG_1, 0x30303030},
	{TX_PWR_CFG_2, 0x30303030},
	{TX_PWR_CFG_3, 0x30303030},
	{TX_PWR_CFG_4, 0x30303030},
	{TX_PWR_CFG_7, 0x30303030},
	{TX_PWR_CFG_8, 0x30},
	{TX_PWR_CFG_9, 0x30},

	{MT7650_EFUSE_CTRL, 0xD000}
};

static UCHAR RT6590_NUM_MAC_REG_PARMS = (sizeof(RT6590_MACRegTable) / sizeof(RTMP_REG_PAIR));

static RTMP_REG_PAIR RT6590_BBP_InitRegTb_GBand[] = {
	{CORE_R1,	0x00000040}, // BW 80
	{CORE_R4,	0x00000000},
	{CORE_R24,	0x00000000}, // Normal Tx mode
	{CORE_R32,	0x4003000a},
	{CORE_R42,	0x00000000}, // Disable noise histogram measurement
	{CORE_R44,	0x00000000}, // No Rxer noise floor measurement report

/*
	IBI - IN BAND REGISTER
	Initial values of these registers will be written by MAC. Driver doesn't need to write.	
*/

	{AGC1_R0,	0x00021400}, // BW 20
	{AGC1_R1,	0x00000001}, // Rx PE delay
	{AGC1_R2,	0x003A6464}, // CCA ED thresholds
	{AGC1_R4,	0x1FF6A652}, // Gain setting0 for Rx0

	{AGC1_R8,	0x102C40C0}, // Gain setting1 for Rx0

	{AGC1_R12,	0x703028F9}, // Gain control settings
	{AGC1_R13,	0x3D120412},
	{AGC1_R14,	0x00003202},
/*
	AGC1_R18, AGC1_R19, AGC1_R20, AGC1_R21: R only
*/
	{AGC1_R22,	0x00001E21},
	{AGC1_R23,	0x0000272C},
	{AGC1_R24,	0x00002F3A},
	{AGC1_R25,	0x8000005A}, // Fine sync timing delay setting
	{AGC1_R26,	0x00602004},
	{AGC1_R27,	0x000000C8}, // Frequency offset setting
	{AGC1_R28,	0x00060806}, // FOE auto correlation timing
	{AGC1_R30,	0x00000006},
	{AGC1_R31,	0x00000F03},
	{AGC1_R32,	0x00002828},
	{AGC1_R33,	0x00003218},
	{AGC1_R34,	0x000A0008},
	{AGC1_R35,	0x11111116},
	{AGC1_R37,	0x2121262C},
	{AGC1_R39,	0x2A2A3036},
	{AGC1_R41,	0x38383E45},
	{AGC1_R43,	0x27273438},
	{AGC1_R45,	0x26263034},
	{AGC1_R47,	0x26263438},
	{AGC1_R49,	0x3333393E},
	{AGC1_R51,	0x17171C1C},
	{AGC1_R53,	0x26262A2F},
	{AGC1_R55,	0x40404E58},
	{AGC1_R57,	0x00001010},
	{AGC1_R58,	0x00001010},
	{AGC1_R59,	0x004B28FF},
	{AGC1_R60,	0x0000FFFF},
	{AGC1_R61,	0x404C362C},
	{AGC1_R62,	0x00362E2C},
	{AGC1_R63,	0x00006E30},

	{TXC_R0, 	0x00280403},
	{TXC_R1, 	0x00000000}, // Normal Tx sin wave control

	{RXC_R1,	0x00000012}, // Bit range mapping and 11b preamble threshold
	{RXC_R2,	0x00000011}, // 11b tracking loop control
	{RXC_R3,	0x00000005}, // 11b adaptive filter control and high-pass filter
	{RXC_R4,	0x00000000}, // 11b timing control and EQ control

	{TXO_R0,	0x00000081},
	{TXO_R1,	0x0000010B},
	{TXO_R2,	0x00000000},
	{TXO_R3,	0x00040008},
	{TXO_R4,	0x00000006},
	{TXO_R5,	0x00C003F4},
	{TXO_R6,	0x00000000},
	{TXO_R7,	0x000E0000},
	{TXO_R8,	0x00000000},

	{TXBE_R0,	0x00000000},
	{TXBE_R1,	0x00101010},
	{TXBE_R2,	0x00000000},
	{TXBE_R3,	0x00000000},
	{TXBE_R4,	0x0000000C},
	{TXBE_R5,	0x00000000},
	{TXBE_R6,	0x00000000},
	{TXBE_R8,	0x00000014},
	{TXBE_R9,	0x20000000},
	{TXBE_R10,	0x00000000},
	{TXBE_R12,	0x00000000},
	{TXBE_R13,	0x00000000},
	{TXBE_R14,	0x00000000},
	{TXBE_R15,	0x00000000},
	{TXBE_R16,	0x00000000},
	{TXBE_R17,	0x00000000},

	{RXFE_R0,	0x006000E0},
	{RXFE_R3,	0x00000000},
	{RXFE_R4,	0x00000000},

	{RXO_R13,	0x00000012},
	{RXO_R14,	0x00060612},
	{RXO_R15,	0xC8321918},
	{RXO_R16,	0x0000001E},
	{RXO_R17,	0x00000000},
	{RXO_R21,	0x00000001}, // FSD d scaling (result from FEQ)
	{RXO_R24,	0x00000006}, // FSD d scaling (result from FEQ)
	{RXO_R28,	0x0000003F}, // RF loopback test control and BIST EVM report

	{CAL_R0, 0x00000000}, 
	{CAL_R1, 0x00000000}, 
	{CAL_R2, 0x00000000}, 
	{CAL_R3, 0x00000000}, 
	{CAL_R4, 0x000000FF},  // Enable all compensation (bbp and RF)
	{CAL_R5, 0x00000000}, 
	{CAL_R6, 0x00000000}, 
	{CAL_R7, 0x00000000}, 

	{CAL_R9, 0x00000000}, 
	{CAL_R10, 0x00000000}, 

	{CAL_R14, 0x00000000}, 
	{CAL_R15, 0x00000000}, 

	{CAL_R18, 0x00000000}, 
	{CAL_R19, 0x00000000}, 

	{CAL_R23, 0x00000000}, 
	{CAL_R24, 0x00000000}, 
	{CAL_R25, 0x00000000}, 

	{CAL_R28, 0x00000000}, 
	{CAL_R29, 0x00000000}, 

	{CAL_R36, 0x00000000}, 
	{CAL_R37, 0x00000000}, 

	{CAL_R40, 0x00000000}, 
	{CAL_R41, 0x00000000}, 

	{CAL_R46, 0x00000000}, 
	{CAL_R47, 0x00000000}, 
	{CAL_R48, 0x00000000}, 
	{CAL_R49, 0x00000000}, 
	{CAL_R50, 0x00000000}, 
	{CAL_R51, 0x00000000}, 
	{CAL_R52, 0x00000000}, 
	{CAL_R53, 0x00000000}, 
	{CAL_R54, 0x00000000}, 
	{CAL_R55, 0x00000000},

	{CAL_R58, 0x00000000}, 
	{CAL_R59, 0x00000000}, 
	{CAL_R60, 0x00000000}, 
	{CAL_R61, 0x00000000}, 
};
static UCHAR RT6590_BBP_InitRegTb_GBand_Tab_Size = (sizeof(RT6590_BBP_InitRegTb_GBand) / sizeof(RTMP_REG_PAIR));

/* Bank	Register Value(Hex) */
static BANK_RF_REG_PAIR RT6590_RF_Central_RegTb[] = {
/*
	Bank 0 - For central blocks: BG, PLL, XTAL, LO, ADC/DAC
*/
	{RF_BANK0,	RF_R01, 0x01},
	{RF_BANK0,	RF_R02, 0x11},

	/*
		R3 ~ R7: VCO Cal.
	*/	
	{RF_BANK0,	RF_R03, 0x80}, /* Disable VCO cal by pass mode */
	{RF_BANK0,	RF_R04, 0x00}, /* R4 b<7>=1, VCO cal */
	{RF_BANK0,	RF_R05, 0x00},
	{RF_BANK0,	RF_R06, 0x41}, /* Set the open loop amplitude to middle since bypassing amplitude calibration */
	{RF_BANK0,	RF_R07, 0x00},

	/*
		XO
	*/
	{RF_BANK0,	RF_R08, 0x80}, 
	{RF_BANK0,	RF_R09, 0x00},
	{RF_BANK0,	RF_R10, 0x0C},
	{RF_BANK0,	RF_R11, 0x00},
	{RF_BANK0,	RF_R12, 0x00}, /* by EEPROM b<5:0> Frequency offset */

	/*
		BG
	*/
	{RF_BANK0,	RF_R13, 0x00},
	{RF_BANK0,	RF_R14, 0x00},
	{RF_BANK0,	RF_R15, 0x00},

	/*
		LDO
	*/
	{RF_BANK0,	RF_R16, 0x00},
	{RF_BANK0,	RF_R17, 0x00},
	{RF_BANK0,	RF_R18, 0x00},
	{RF_BANK0,	RF_R19, 0x00},

	/*
		XO
	*/
	{RF_BANK0,	RF_R20, 0x22},
	{RF_BANK0,	RF_R21, 0x02},
	{RF_BANK0,	RF_R22, 0x21/*0x3F*/}, /* XTAL Freq offset, varies */ // TODO: we need to read this value from EEPROM
	{RF_BANK0,	RF_R23, 0x00}, 
	{RF_BANK0,	RF_R24, 0x00}, /* XTAL is the same as PLL frequency ref. No need to divide */
	{RF_BANK0,	RF_R25, 0x00},

	/*
		PLL
	*/
	{RF_BANK0,	RF_R26, 0x00},
	{RF_BANK0,	RF_R27, 0x00},
	{RF_BANK0,	RF_R28, 0x20},
#if 0 /* Follow PLL N table */
	{RF_BANK0,	RF_R29, 0x50},
#endif
	{RF_BANK0,	RF_R30, 0x02}, /* Use Frac N accumulator mod, bit 0 following PLL N table */
#if 0 /* Follow PLL K table */
	{RF_BANK0,	RF_R31, 0x4C},
#endif
	{RF_BANK0,	RF_R32, 0x16},
	{RF_BANK0,	RF_R33, 0x25},
	{RF_BANK0,	RF_R34, 0x11},
	{RF_BANK0,	RF_R35, 0x38}, /* Change setting to reduce spurs */
	{RF_BANK0,	RF_R36, 0x6E},
	{RF_BANK0,	RF_R37, 0x00},	

	/*
		LO Buffer
	*/
	{RF_BANK0,	RF_R38, 0x25},
	{RF_BANK0,	RF_R39, 0x35}, /* Adjust LO buffer tank */
	
	/*
		Test Ports
	*/
	{RF_BANK0,	RF_R64, 0x00},
	{RF_BANK0,	RF_R65, 0x00},
	{RF_BANK0,	RF_R66, 0x00},
	{RF_BANK0,	RF_R67, 0x00},

	/*
		ADC/DAC
	*/
	{RF_BANK0,	RF_R68, 0x00},
	{RF_BANK0,	RF_R69, 0x08},
	{RF_BANK0,	RF_R70, 0x08},
	{RF_BANK0,	RF_R71, 0x40},
	{RF_BANK0,	RF_R72, 0xD0},
	{RF_BANK0,	RF_R73, 0x93},
};
static UINT32 RT6590_RF_Central_RegTb_Size = (sizeof(RT6590_RF_Central_RegTb) / sizeof(BANK_RF_REG_PAIR));

static BANK_RF_REG_PAIR RT6590_RF_2G_Channel_0_RegTb[] = {
/*
	Bank 5 - Channel 0 2G RF registers	
*/
	/*
		RX logic operation
	*/
	{RF_BANK5,	RF_R00, 0x00}, // Change in SelectBand6590
	{RF_BANK5,	RF_R01, 0x00},
	{RF_BANK5,	RF_R02, 0x0B},
	{RF_BANK5,	RF_R03, 0x00},

	/*
		TX logic operation
	*/
	{RF_BANK5,	RF_R04, 0x00},
	{RF_BANK5,	RF_R05, 0x80},
	{RF_BANK5,	RF_R06, 0x02},

	/*
		LDO
	*/
	{RF_BANK5,	RF_R07, 0x00},
	{RF_BANK5,	RF_R08, 0x00},
	{RF_BANK5,	RF_R09, 0x00},

	/*
		RX
	*/
	{RF_BANK5,	RF_R10, 0x51},
	{RF_BANK5,	RF_R11, 0x22},
	{RF_BANK5,	RF_R12, 0x22},
	{RF_BANK5,	RF_R13, 0x0F},
	{RF_BANK5,	RF_R14, 0x47}, /* Increase mixer current for more gain */
	{RF_BANK5,	RF_R15, 0x25},
	{RF_BANK5,	RF_R16, 0xC7}, /* Tune LNA2 tank */
	{RF_BANK5,	RF_R17, 0x00},
	{RF_BANK5,	RF_R18, 0x00},
	{RF_BANK5,	RF_R19, 0x00},
	{RF_BANK5,	RF_R20, 0x33},
	{RF_BANK5,	RF_R21, 0x02},
	{RF_BANK5,	RF_R22, 0x32}, /* Tune LNA1 tank */
	{RF_BANK5,	RF_R23, 0x00},
	{RF_BANK5,	RF_R24, 0x25},
	{RF_BANK5,	RF_R25, 0x13}, /* Tune LNA0 tank */
	{RF_BANK5,	RF_R26, 0x00},
	{RF_BANK5,	RF_R27, 0x12},
	{RF_BANK5,	RF_R28, 0x08},
	{RF_BANK5,	RF_R29, 0x00},

	/*
		LOGEN
	*/
	{RF_BANK5,	RF_R30, 0x41}, /* Tune LOGEN tank */
	{RF_BANK5,	RF_R31, 0x71},
	{RF_BANK5,	RF_R32, 0x31},
	{RF_BANK5,	RF_R33, 0x31},
	{RF_BANK5,	RF_R34, 0x34},
	{RF_BANK5,	RF_R35, 0x00},
	{RF_BANK5,	RF_R36, 0x00},

	/*
		TX
	*/
	{RF_BANK5,	RF_R37, 0xBB},
	{RF_BANK5,	RF_R38, 0xB3},
	{RF_BANK5,	RF_R39, 0x33},
	{RF_BANK5,	RF_R40, 0xB3},
	{RF_BANK5,	RF_R41, 0x31},
	{RF_BANK5,	RF_R42, 0xF2},
	{RF_BANK5,	RF_R43, 0x30}, /* Tune mixer tank */
	{RF_BANK5,	RF_R44, 0x17},
	{RF_BANK5,	RF_R45, 0x02},
	{RF_BANK5,	RF_R46, 0x15},
	{RF_BANK5,	RF_R47, 0x00},
	{RF_BANK5,	RF_R48, 0x53},
	{RF_BANK5,	RF_R49, 0x04},
	{RF_BANK5,	RF_R50, 0x67},
	{RF_BANK5,	RF_R51, 0x67},
	{RF_BANK5,	RF_R52, 0x67},
	{RF_BANK5,	RF_R53, 0x67},
	{RF_BANK5,	RF_R54, 0xFF},
	{RF_BANK5,	RF_R55, 0xFF},
	{RF_BANK5,	RF_R56, 0xFF},
	{RF_BANK5,	RF_R57, 0xFF},
	{RF_BANK5,	RF_R58, 0x36},
	{RF_BANK5,	RF_R59, 0x36},
	{RF_BANK5,	RF_R60, 0x36},
	{RF_BANK5,	RF_R61, 0x36},
	{RF_BANK5,	RF_R62, 0x4C},
	{RF_BANK5,	RF_R63, 0x4F},
	{RF_BANK5,	RF_R64, 0x55},
	{RF_BANK5, 	RF_R65, 0x55},
	{RF_BANK5,	RF_R66, 0xF0},
	{RF_BANK5,	RF_R67, 0xF0},
	{RF_BANK5,	RF_R68, 0xF0},
	{RF_BANK5,	RF_R69, 0xF0},
	
	{RF_BANK5,	RF_R127, 0x04},
};
static UINT32 RT6590_RF_2G_Channel_0_RegTb_Size = (sizeof(RT6590_RF_2G_Channel_0_RegTb) / sizeof(BANK_RF_REG_PAIR));

static BANK_RF_REG_PAIR RT6590_RF_5G_Channel_0_RegTb[] = {
/*
	Bank 6 - Channel 0 5G RF registers	
*/
	/*
		RX logic operation
	*/
	{RF_BANK6,	RF_R00, 0x00}, // Change in SelectBand6590
	{RF_BANK6,	RF_R01, 0x00},
	{RF_BANK6,	RF_R02, 0x0C}, // Int SW diverity , RX0: 0x0C
	{RF_BANK6,	RF_R03, 0x00},

	/*
		TX logic operation
	*/
	{RF_BANK6,	RF_R04, 0x00},
	{RF_BANK6,	RF_R05, 0x80},
	{RF_BANK6,	RF_R06, 0x02},

	/*
		LDO
	*/
	{RF_BANK6,	RF_R07, 0x00},
	{RF_BANK6,	RF_R08, 0x00},
	{RF_BANK6,	RF_R09, 0x00},

	/*
		RX
	*/
	{RF_BANK6,	RF_R10, 0x00},
	{RF_BANK6,	RF_R11, 0x01},
	{RF_BANK6,	RF_R12, 0x33},
	{RF_BANK6,	RF_R13, 0x23},
	{RF_BANK6,	RF_R14, 0x00},
	{RF_BANK6,	RF_R15, 0x04},
	{RF_BANK6,	RF_R16, 0x04},
	{RF_BANK6,	RF_R17, 0x03},
	{RF_BANK6,	RF_R18, 0x08},
	{RF_BANK6,	RF_R19, 0x00},
	{RF_BANK6,	RF_R20, 0x00},
	{RF_BANK6,	RF_R21, 0x22},

	/*
		LOGEN5G
	*/
	{RF_BANK6,	RF_R24, 0xF1},
	{RF_BANK6,	RF_R25, 0x76},
	{RF_BANK6,	RF_R26, 0x24},
	{RF_BANK6,	RF_R27, 0x04},

	/*
		TX
	*/
	{RF_BANK6,	RF_R37, 0xBB},
	{RF_BANK6,	RF_R38, 0xB3},
	{RF_BANK6,	RF_R39, 0x36},
	{RF_BANK6,	RF_R40, 0x33},
	{RF_BANK6,	RF_R41, 0x33},
	{RF_BANK6,	RF_R42, 0x83/*0xB3*/},
	{RF_BANK6,	RF_R43, 0x1B},
	{RF_BANK6,	RF_R44, 0xB3},
	{RF_BANK6,	RF_R45, 0x5C},
	{RF_BANK6,	RF_R46, 0x17},
	{RF_BANK6,	RF_R47, 0x02},
	{RF_BANK6,	RF_R48, 0x15},
	{RF_BANK6,	RF_R49, 0x07},
	{RF_BANK6,	RF_R50, 0x05},
	{RF_BANK6,	RF_R51, 0x0C},
	{RF_BANK6,	RF_R52, 0x4C},
	{RF_BANK6,	RF_R53, 0x4C},
	{RF_BANK6, 	RF_R54, 0x04},
	{RF_BANK6,	RF_R55, 0x04},
	{RF_BANK6,	RF_R56, 0x18},
	{RF_BANK6,	RF_R57, 0x18},
	{RF_BANK6,	RF_R58, 0x04},
	{RF_BANK6,	RF_R59, 0x04},
	{RF_BANK6,	RF_R60, 0x00},
	{RF_BANK6,	RF_R61, 0x00},
	{RF_BANK6,	RF_R62, 0x00},
	{RF_BANK6,	RF_R63, 0x00},
	{RF_BANK6,	RF_R64, 0xF0},
	{RF_BANK6,	RF_R65, 0x0F},
	{RF_BANK6, 	RF_R66, 0x02},
	{RF_BANK6,	RF_R67, 0x02},
	{RF_BANK6,	RF_R68, 0x00},
	{RF_BANK6,	RF_R69, 0x00},
	
	{RF_BANK6,	RF_R127, 0x04},
};
static UINT32 RT6590_RF_5G_Channel_0_RegTb_Size = (sizeof(RT6590_RF_5G_Channel_0_RegTb) / sizeof(BANK_RF_REG_PAIR));

static BANK_RF_REG_PAIR RT6590_RF_VGA_Channel_0_RegTb[] = {
/*
	Bank 7 - Channel 0 VGA RF registers	
*/
	{RF_BANK7,	RF_R00, 0x47},
	{RF_BANK7,	RF_R01, 0x00},
	{RF_BANK7,	RF_R02, 0x00},
	{RF_BANK7,	RF_R03, 0x00},
	{RF_BANK7,	RF_R04, 0x00},
	{RF_BANK7,	RF_R05, 0x00}, // No DPD
/*
	{RF_BANK7,	RF_R06, 0x40}, // RX Filter
	{RF_BANK7,	RF_R07, 0x40}, // RX Filter
	{RF_BANK7,	RF_R08, 0x03}, // AFC setting
*/
	{RF_BANK7,	RF_R09, 0x40},
	{RF_BANK7,	RF_R10, 0x07},
	{RF_BANK7,	RF_R11, 0x01},
	{RF_BANK7,	RF_R12, 0x07},
	{RF_BANK7,	RF_R13, 0x07},
	{RF_BANK7,	RF_R14, 0x07},
	{RF_BANK7,	RF_R15, 0x20},
	{RF_BANK7,	RF_R16, 0x22},
	{RF_BANK7,	RF_R17, 0x00},
	{RF_BANK7,	RF_R18, 0x00},
	{RF_BANK7,	RF_R19, 0x00},
	{RF_BANK7,	RF_R20, 0x00},
	{RF_BANK7,	RF_R21, 0xF1},
	{RF_BANK7,	RF_R22, 0x11},
	{RF_BANK7,	RF_R23, 0xC2},
	{RF_BANK7,	RF_R24, 0x41},
	{RF_BANK7,	RF_R25, 0x20},
	{RF_BANK7,	RF_R26, 0x40},
	{RF_BANK7,	RF_R27, 0xD7},
	{RF_BANK7,	RF_R28, 0xA2},
	{RF_BANK7,	RF_R29, 0x60},
	{RF_BANK7,	RF_R30, 0x49},
	{RF_BANK7,	RF_R31, 0x20},
	{RF_BANK7,	RF_R32, 0x44},
	{RF_BANK7,	RF_R33, 0xC1},
	{RF_BANK7,	RF_R34, 0x60},
	{RF_BANK7,	RF_R35, 0xC0},
	{RF_BANK7,	RF_R36, 0x00},
	{RF_BANK7,	RF_R37, 0x00},
	{RF_BANK7,	RF_R38, 0x00},
	{RF_BANK7,	RF_R39, 0x00},
	{RF_BANK7,	RF_R40, 0x00},
	{RF_BANK7,	RF_R41, 0x00},
	{RF_BANK7,	RF_R42, 0x00},
	{RF_BANK7,	RF_R43, 0x00},
	{RF_BANK7,	RF_R44, 0x00},
	{RF_BANK7,	RF_R45, 0x00},
	{RF_BANK7,	RF_R46, 0x00},
	{RF_BANK7,	RF_R47, 0x00},
	{RF_BANK7,	RF_R48, 0x00},
	{RF_BANK7,	RF_R49, 0x00},
	{RF_BANK7,	RF_R50, 0x00},
	{RF_BANK7,	RF_R51, 0x00},
	{RF_BANK7,	RF_R52, 0x00},
	{RF_BANK7,	RF_R53, 0x00},
	{RF_BANK7,	RF_R54, 0x00},
	{RF_BANK7,	RF_R55, 0x00},
	{RF_BANK7,	RF_R56, 0x00},
	{RF_BANK7,	RF_R57, 0x00},
/*
	{RF_BANK7,	RF_R58, 0x40},
	{RF_BANK7,	RF_R59, 0x40},
*/
	{RF_BANK7,	RF_R60, 0x8A/*0x0A*/},
	{RF_BANK7,	RF_R61, 0x01},
	{RF_BANK7,	RF_R62, 0x00},
	{RF_BANK7,	RF_R63, 0x00},
	{RF_BANK7,	RF_R64, 0x00},
	{RF_BANK7,	RF_R65, 0x00},
	{RF_BANK7,	RF_R66, 0x00},
	{RF_BANK7,	RF_R67, 0x00},
	{RF_BANK7,	RF_R68, 0x00},
	{RF_BANK7,	RF_R69, 0x00},
	{RF_BANK7,	RF_R70, 0x00},
	{RF_BANK7,	RF_R71, 0x00},
	{RF_BANK7,	RF_R72, 0x00},
	{RF_BANK7,	RF_R73, 0x00},
	{RF_BANK7,	RF_R74, 0x00},
	{RF_BANK7,	RF_R75, 0x00},
	{RF_BANK7,	RF_R126, 0x00},
	{RF_BANK7,	RF_R127, 0x00},
};
static UINT32 RT6590_RF_VGA_Channel_0_RegTb_Size = (sizeof(RT6590_RF_VGA_Channel_0_RegTb) / sizeof(BANK_RF_REG_PAIR));

#if 0
	Rdiv: R24[1:0]
	PLL_N: R29[7:0], R30[0]
	pll_k(Nominator): R31[4:0]
	Non-Sigma: !SDM R31[7:5]
	Den: (Denomina - 8) R32[4:0]
	Loop Filter Config: R33, R34
	Pll_idiv: frac comp R35[6:0]
#endif
static const RT6590_FREQ_ITEM RT6590_Frequency_Plan[] =
{

	/* Channel, Band,		PLL_N,	Pll_k, 	Rdiv,	Non-Sigma, 	Den,	LFC_R33,	LFC_R34,	Pll_idiv */
		{1,		RF_G_BAND,	0x28, 	0x02, 	0x03, 	0x40, 		0x02,		0x24,		0x5D,		0x28},
		{2, 	RF_G_BAND,	0xA1, 	0x02, 	0x01, 	0x40, 		0x07,		0x24,		0x5D,		0x3C},
		{3, 	RF_G_BAND,	0x50, 	0x0B, 	0x00, 	0x40, 		0x07,		0x24,		0x5D,		0x3C},
		{4, 	RF_G_BAND,	0x50, 	0x09, 	0x00, 	0x40, 		0x02,		0x24,		0x5D,		0x28},
		{5, 	RF_G_BAND,	0xA2, 	0x02, 	0x01, 	0x40, 		0x07,		0x24,		0x5D,		0x3C},
		{6, 	RF_G_BAND,	0xA2, 	0x07, 	0x01, 	0x40, 		0x07,		0x24,		0x5D,		0x3C},
		{7, 	RF_G_BAND,	0x28, 	0x07, 	0x03, 	0x40, 		0x02,		0x24,		0x5D,		0x28},
		{8, 	RF_G_BAND,	0xA3, 	0x02, 	0x01, 	0x40, 		0x07,		0x24,		0x5D,		0x3C},
		{9, 	RF_G_BAND,	0x28, 	0x0D, 	0x03, 	0x40, 		0x07,		0x24,		0x5D,		0x3C},
		{10, 	RF_G_BAND,	0x51, 	0x09, 	0x00, 	0x40, 		0x02,		0x24,		0x5D,		0x28},
		{11, 	RF_G_BAND,	0xA4, 	0x02, 	0x01, 	0x40, 		0x07,		0x24,		0x5D,		0x3C},
		{12, 	RF_G_BAND,	0xA4, 	0x07, 	0x01, 	0x40, 		0x07,		0x24,		0x5D,		0x3C},
		{13, 	RF_G_BAND,	0x29, 	0x02, 	0x03, 	0x40, 		0x02,		0x24,		0x5D,		0x28},
		{14, 	RF_G_BAND,	0x29, 	0x04, 	0x03, 	0x40, 		0x02,		0x24,		0x5D,		0x28},

	/* Channel, Band,						PLL_N, 	PLL_K,	Rdiv,	Non-Sigma, 	Den,	LFC_R33,	LFC_R34,	Pll_idiv */
		{36, 	(RF_A_BAND | RF_A_BAND_LB),	0x2B, 	0x02, 	0x03,	0x40, 		0x04,		0x33,		0x5D,		0x30},
		{38, 	(RF_A_BAND | RF_A_BAND_LB),	0x2B, 	0x03, 	0x03,	0x40, 		0x04,		0x33,		0x5D,		0x30},
		{40, 	(RF_A_BAND | RF_A_BAND_LB),	0x2B, 	0x04, 	0x03,	0x40, 		0x04,		0x33,		0x5D,		0x30},
		{42, 	(RF_A_BAND | RF_A_BAND_LB),	0x2B, 	0x05, 	0x03,	0x40, 		0x04,		0x33,		0x5D,		0x30},
		{44, 	(RF_A_BAND | RF_A_BAND_LB),	0x2B, 	0x06, 	0x03,	0x40, 		0x04,		0x33,		0x5D,		0x30},
		{46, 	(RF_A_BAND | RF_A_BAND_LB),	0x2B, 	0x07, 	0x03,	0x40, 		0x04,		0x33,		0x5D,		0x30},
		{48, 	(RF_A_BAND | RF_A_BAND_LB),	0x2B, 	0x08, 	0x03,	0x40, 		0x04,		0x33,		0x5D,		0x30},
		{50, 	(RF_A_BAND | RF_A_BAND_LB),	0x2B, 	0x09, 	0x03,	0x40, 		0x04,		0x33,		0x5D,		0x30},
		{52, 	(RF_A_BAND | RF_A_BAND_LB),	0x2B, 	0x0A, 	0x03,	0x40, 		0x04,		0x33,		0x5D,		0x30},
		{54, 	(RF_A_BAND | RF_A_BAND_LB),	0x57, 	0x0A, 	0x00,	0x40, 		0x04,		0x33,		0x5D,		0x30},
		{56, 	(RF_A_BAND | RF_A_BAND_LB),	0x2C, 	0x00, 	0x03,	0x40, 		0x04,		0x33,		0x5D,		0x30},
		{58, 	(RF_A_BAND | RF_A_BAND_LB),	0x58, 	0x02, 	0x00,	0x40, 		0x04,		0x33,		0x5D,		0x30},
		{60, 	(RF_A_BAND | RF_A_BAND_LB),	0x2C, 	0x02, 	0x03,	0x40, 		0x04,		0x33,		0x5D,		0x30},
		{62, 	(RF_A_BAND | RF_A_BAND_LB),	0x2C, 	0x03, 	0x03,	0x40, 		0x04,		0x33,		0x5D,		0x30},
		{64, 	(RF_A_BAND | RF_A_BAND_LB),	0x2C, 	0x04, 	0x03,	0x40, 		0x04,		0x33,		0x5D,		0x30},
		{100, 	(RF_A_BAND | RF_A_BAND_MB),	0x2D, 	0x0A, 	0x03,	0x40, 		0x04,		0x23,		0x5D,		0x30},
		{102, 	(RF_A_BAND | RF_A_BAND_MB),	0x5B, 	0x0A, 	0x00,	0x40, 		0x04,		0x23,		0x5D,		0x30},
		{104, 	(RF_A_BAND | RF_A_BAND_MB),	0x2E, 	0x00, 	0x03,	0x40, 		0x04,		0x23,		0x5D,		0x30},
		{106, 	(RF_A_BAND | RF_A_BAND_MB),	0x5C, 	0x02, 	0x00,	0x40, 		0x04,		0x23,		0x5D,		0x30},
		{108, 	(RF_A_BAND | RF_A_BAND_MB),	0x2E, 	0x02, 	0x03,	0x40, 		0x04,		0x23,		0x5D,		0x30},
		{110, 	(RF_A_BAND | RF_A_BAND_MB),	0x2E, 	0x03, 	0x03,	0x40, 		0x04,		0x23,		0x5D,		0x30},
		{112, 	(RF_A_BAND | RF_A_BAND_MB),	0x2E, 	0x04, 	0x03,	0x40, 		0x04,		0x23,		0x5D,		0x30},
		{114, 	(RF_A_BAND | RF_A_BAND_MB),	0x2E, 	0x05, 	0x03,	0x40, 		0x04,		0x23,		0x5D,		0x30},
		{116, 	(RF_A_BAND | RF_A_BAND_MB),	0x2E, 	0x06, 	0x03,	0x40, 		0x04,		0x23,		0x5D,		0x30},
		{118, 	(RF_A_BAND | RF_A_BAND_MB),	0x2E, 	0x07, 	0x03,	0x40, 		0x04,		0x23,		0x5D,		0x30},
		{120, 	(RF_A_BAND | RF_A_BAND_MB),	0x2E, 	0x08, 	0x03,	0x40, 		0x04,		0x23,		0x5D,		0x30},
		{122, 	(RF_A_BAND | RF_A_BAND_MB),	0x2E, 	0x09, 	0x03,	0x40, 		0x04,		0x23,		0x5D,		0x30},
		{124, 	(RF_A_BAND | RF_A_BAND_MB),	0x2E, 	0x0A, 	0x03,	0x40, 		0x04,		0x23,		0x5D,		0x30},
		{126, 	(RF_A_BAND | RF_A_BAND_MB),	0x5D, 	0x0A, 	0x00,	0x40, 		0x04,		0x23,		0x5D,		0x30},
		{128, 	(RF_A_BAND | RF_A_BAND_MB),	0x2F, 	0x00, 	0x03,	0x40, 		0x04,		0x23,		0x5D,		0x30},
		{130, 	(RF_A_BAND | RF_A_BAND_MB),	0x5E, 	0x02, 	0x00,	0x40, 		0x04,		0x23,		0x5D,		0x30},
		{132, 	(RF_A_BAND | RF_A_BAND_MB),	0x2F, 	0x02, 	0x03,	0x40, 		0x04,		0x23,		0x5D,		0x30},
		{134, 	(RF_A_BAND | RF_A_BAND_MB),	0x2F, 	0x03, 	0x03,	0x40, 		0x04,		0x23,		0x5D,		0x30},
		{136, 	(RF_A_BAND | RF_A_BAND_MB),	0x2F, 	0x04, 	0x03,	0x40, 		0x04,		0x23,		0x5D,		0x30},
		{138, 	(RF_A_BAND | RF_A_BAND_MB),	0x2F, 	0x05, 	0x03,	0x40, 		0x04,		0x23,		0x5D,		0x30},
		{140, 	(RF_A_BAND | RF_A_BAND_MB),	0x2F, 	0x06, 	0x03,	0x40, 		0x04,		0x23,		0x5D,		0x30},
		{142, 	(RF_A_BAND | RF_A_BAND_HB),	0x2F, 	0x07, 	0x03,	0x40, 		0x04,		0x23,		0x5D,		0x30},
		{144, 	(RF_A_BAND | RF_A_BAND_HB),	0x2F, 	0x08, 	0x03,	0x40, 		0x04,		0x23,		0x5D,		0x30},
		{146, 	(RF_A_BAND | RF_A_BAND_HB),	0x2F, 	0x09, 	0x03,	0x40, 		0x04,		0x23,		0x5D,		0x30},
		{149, 	(RF_A_BAND | RF_A_BAND_HB),	0x2F, 	0x15, 	0x03,	0x40, 		0x10,		0x23,		0x5D,		0x60},
		{151, 	(RF_A_BAND | RF_A_BAND_HB),	0x5F, 	0x0B, 	0x00,	0x40, 		0x04,		0x23,		0x5D,		0x30},
		{153, 	(RF_A_BAND | RF_A_BAND_HB),	0x60, 	0x01, 	0x00,	0x40, 		0x04,		0x23,		0x5D,		0x30},
		{155, 	(RF_A_BAND | RF_A_BAND_HB),	0x30, 	0x03, 	0x03,	0x40, 		0x10,		0x23,		0x5D,		0x60},
		{157, 	(RF_A_BAND | RF_A_BAND_HB),	0x30, 	0x05, 	0x03,	0x40, 		0x10,		0x23,		0x5D,		0x60},
		{159, 	(RF_A_BAND | RF_A_BAND_HB),	0x30, 	0x07, 	0x03,	0x40, 		0x10,		0x23,		0x5D,		0x60},
		{161, 	(RF_A_BAND | RF_A_BAND_HB),	0x30, 	0x09, 	0x03,	0x40, 		0x10,		0x23,		0x5D,		0x60},
		{163, 	(RF_A_BAND | RF_A_BAND_HB),	0x30, 	0x0B, 	0x03,	0x40, 		0x10,		0x23,		0x5D,		0x60},
		{165, 	(RF_A_BAND | RF_A_BAND_HB),	0x30, 	0x0D, 	0x03,	0x40, 		0x10,		0x23,		0x5D,		0x60},
};
UCHAR NUM_OF_6590_CHNL = (sizeof(RT6590_Frequency_Plan) / sizeof(RT6590_FREQ_ITEM));

static const RT6590_RF_SWITCH_ITEM RT6590_RF_BW_Switch[] =
{
	/*   Bank, 		Register,	Aband,	BW, 	Value */
		{RF_BANK7,	RF_R06,		0xFF,	BW_20,	0x40},
		{RF_BANK7,	RF_R06,		0xFF,	BW_40,	0x18/*0x20*/},
		{RF_BANK7,	RF_R06,		0xFF,	BW_80,	0x0B/*0x10*/},

		{RF_BANK7,	RF_R07,		0xFF,	BW_20,	0x40},
		{RF_BANK7,	RF_R07,		0xFF,	BW_40,	0x18/*0x20*/},
		{RF_BANK7,	RF_R07,		0xFF,	BW_80,	0x0B/*0x10*/},

		{RF_BANK7,	RF_R08,		0xFF,	BW_20,	0x03},
		{RF_BANK7,	RF_R08,		0xFF,	BW_40,	0x01},
		{RF_BANK7,	RF_R08,		0xFF,	BW_80,	0x00},

		{RF_BANK7,	RF_R58,		0xFF,	BW_20,	0x40},
		{RF_BANK7,	RF_R58,		0xFF,	BW_40,	0x20},
		{RF_BANK7,	RF_R58,		0xFF,	BW_80,	0x10},

		{RF_BANK7,	RF_R59,		0xFF,	BW_20,	0x40},
		{RF_BANK7,	RF_R59,		0xFF,	BW_40,	0x20},
		{RF_BANK7,	RF_R59,		0xFF,	BW_80,	0x10},
};
UCHAR RT6590_RF_BW_Switch_Size = (sizeof(RT6590_RF_BW_Switch) / sizeof(RT6590_RF_SWITCH_ITEM));

static const RT6590_RF_SWITCH_ITEM RT6590_RF_Band_Switch[] =
{
	/*   Bank, 		Register,	Band,			BW, 	Value */
		{RF_BANK0,	RF_R39,		RF_G_BAND,		0xFF,	0x34},
		{RF_BANK0,	RF_R39,		RF_A_BAND_LB,	0xFF,	0x31},
		{RF_BANK0,	RF_R39,		RF_A_BAND_MB,	0xFF,	0x30},
		{RF_BANK0,	RF_R39,		RF_A_BAND_HB,	0xFF,	0x30},
		
		{RF_BANK6,	RF_R13,		RF_A_BAND_LB,	0xFF,	0x23},
		{RF_BANK6,	RF_R13,		RF_A_BAND_MB,	0xFF,	0x26},
		{RF_BANK6,	RF_R13,		RF_A_BAND_HB,	0xFF,	0x26},

		{RF_BANK6,	RF_R15,		RF_A_BAND_LB,	0xFF,	0x04},
		{RF_BANK6,	RF_R15,		RF_A_BAND_MB,	0xFF,	0x04},
		{RF_BANK6,	RF_R15,		RF_A_BAND_HB,	0xFF,	0x04},

		{RF_BANK6,	RF_R16,		RF_A_BAND_LB,	0xFF,	0x04},
		{RF_BANK6,	RF_R16,		RF_A_BAND_MB,	0xFF,	0x04},
		{RF_BANK6,	RF_R16,		RF_A_BAND_HB,	0xFF,	0x05},

		{RF_BANK6,	RF_R17,		RF_A_BAND_LB,	0xFF,	0x03},
		{RF_BANK6,	RF_R17,		RF_A_BAND_MB,	0xFF,	0x00},
		{RF_BANK6,	RF_R17,		RF_A_BAND_HB,	0xFF,	0x00},

		{RF_BANK6,	RF_R24,		RF_A_BAND_LB,	0xFF,	0xF1},
		{RF_BANK6,	RF_R24,		RF_A_BAND_MB,	0xFF,	0xC1},
		{RF_BANK6,	RF_R24,		RF_A_BAND_HB,	0xFF,	0x81},

		{RF_BANK6,	RF_R39,		RF_A_BAND_LB,	0xFF,	0x36},
		{RF_BANK6,	RF_R39,		RF_A_BAND_MB,	0xFF,	0x34},
		{RF_BANK6,	RF_R39,		RF_A_BAND_HB,	0xFF,	0x32},

		{RF_BANK6,	RF_R45,		RF_A_BAND_LB,	0xFF,	0x5C},
		{RF_BANK6,	RF_R45,		RF_A_BAND_MB,	0xFF,	0x2C/*0x4C*/},
		{RF_BANK6,	RF_R45,		RF_A_BAND_HB,	0xFF,	0x0C/*0x2C*/},

		{RF_BANK6,	RF_R58,		RF_A_BAND_LB,	0xFF,	0x04},
		{RF_BANK6,	RF_R58,		RF_A_BAND_MB,	0xFF,	0x03},
		{RF_BANK6,	RF_R58,		RF_A_BAND_HB,	0xFF,	0x02},

		{RF_BANK6,	RF_R59,		RF_A_BAND_LB,	0xFF,	0x04},
		{RF_BANK6,	RF_R59,		RF_A_BAND_MB,	0xFF,	0x03},
		{RF_BANK6,	RF_R59,		RF_A_BAND_HB,	0xFF,	0x02},

		{RF_BANK7,	RF_R70,		RF_G_BAND,		0xFF,	0x00},
		{RF_BANK7,	RF_R70,		RF_A_BAND,		0xFF,	0x4B},

		{RF_BANK7,	RF_R71,		RF_G_BAND,		0xFF,	0x00},
		{RF_BANK7,	RF_R71,		RF_A_BAND,		0xFF,	0x20},
};
UCHAR RT6590_RF_Band_Switch_Size = (sizeof(RT6590_RF_Band_Switch) / sizeof(RT6590_RF_SWITCH_ITEM));


static RTMP_REG_PAIR RT6590_BBPRegTb_GBand[]={
#if 1
	{AGC1_R4,	0x1FF6A652},
	{AGC1_R5,	0x1FEA9C48},
	{AGC1_R9,	0x132C40C0},
	{AGC1_R13,	0x3D120412},
	{AGC1_R14,	0x00003202},
	{AGC1_R26,	0x00602004},
#if 0	
	{AGC1_R30,	0x00000006},
#endif
	{AGC1_R31,	0x00000FC3},
	{AGC1_R35,	0x11111116},
	{AGC1_R43,	0x27273438},
	{AGC1_R45,	0x26263034},
	{AGC1_R47,	0x26263438},
	{AGC1_R51,	0x17171C1C},
	{AGC1_R53,	0x26262A2F},
	{AGC1_R55,	0x40404E58},
#if 0	
	{AGC1_R58,	0x00001010},
	{AGC1_R59,	0x004B28FF},
	{AGC1_R60,	0x0000FFFF},
#endif

	{RXO_R15,	0xC8321918},
#else
	{AGC1_R4,	0x1FEA9C48},
	{AGC1_R5,	0x1FEA9C48},
	{AGC1_R13,	0x3D120412},
	{AGC1_R14,	0x00003202},

	{AGC1_R26,	0x00602004},

	{AGC1_R30,	0x00000006},
	{AGC1_R31,	0x00000FC3},
	{AGC1_R35,	0x11111116},

	{AGC1_R43,	0x27273438},
	{AGC1_R45,	0x26263034},
	{AGC1_R47,	0x26263438},
	
	{AGC1_R51,	0x17171C1C},
	{AGC1_R53,	0x26262A2F},
	{AGC1_R55,	0x40404E58},
	{AGC1_R58,	0x00001010},
	{AGC1_R59,	0x004B28FF},

	{AGC1_R60,	0x0000FFFF},
#endif
};
static UCHAR RT6590_BBP_GBand_Tb_Size = (sizeof(RT6590_BBPRegTb_GBand) / sizeof(RTMP_REG_PAIR));


//2 REMOVE: For test chip only
//
// Initialize TC6008 configurations
//
VOID InitTC6008Config(
	IN PRTMP_ADAPTER pAd)
{
	ULONG MacReg = 0;
	ULONG BbValue = 0;
	
	DBGPRINT(RT_DEBUG_TRACE, ("%s: -->\n", __FUNCTION__));

	/*
		For A1 version: RF_MISC[0] = 0
		For A2 and A3 version: RF_MISC[0] = 1
		20120327 - MT7650 PCIe EVB is A2.
	*/
	RTMP_IO_READ32(pAd, RF_MISC, &MacReg);
	MacReg |= (0x1);
	RTMP_IO_WRITE32(pAd, RF_MISC, MacReg);

	//
	// Disable COEX_EN
	//
	RTMP_IO_READ32(pAd, COEXCFG0, &MacReg);
	MacReg &= 0xFFFFFFFE;
	RTMP_IO_WRITE32(pAd, COEXCFG0, MacReg);

	//
	// Set 0x00000000 to per-rate power control (by JerryCK)
	// Set TxWI.AdjustTxPower to 0x00 (by JerryCK)
	//
	RTMP_IO_WRITE32(pAd, TX_PWR_CFG_0, 0x00000000);
	RTMP_IO_WRITE32(pAd, TX_PWR_CFG_1, 0x00000000);
	RTMP_IO_WRITE32(pAd, TX_PWR_CFG_2, 0x00000000);
	RTMP_IO_WRITE32(pAd, TX_PWR_CFG_3, 0x00000000);
	RTMP_IO_WRITE32(pAd, TX_PWR_CFG_4, 0x00000000);
	RTMP_IO_WRITE32(pAd, TX_PWR_CFG_7, 0x00000000);
	RTMP_IO_WRITE32(pAd, TX_PWR_CFG_8, 0x00000000);
	RTMP_IO_WRITE32(pAd, TX_PWR_CFG_9, 0x00000000);

	RTMP_IO_WRITE32(pAd, CMB_CTRL, 0x0000D7FF);

	DBGPRINT(RT_DEBUG_TRACE, ("%s: <--\n", __FUNCTION__));
}


//
// Initialize FCE
//
VOID InitFce(
	PRTMP_ADAPTER pAd)
{
	L2_STUFFING_STRUC L2Stuffing = {0};

	DBGPRINT(RT_DEBUG_TRACE, ("%s: -->\n", __FUNCTION__));

	RTMP_IO_READ32(pAd, FCE_L2_STUFF, &L2Stuffing.word);
	L2Stuffing.field.FS_WR_MPDU_LEN_EN = 0;
	RTMP_IO_WRITE32(pAd, FCE_L2_STUFF, L2Stuffing.word);

	DBGPRINT(RT_DEBUG_TRACE, ("%s: <--\n", __FUNCTION__));
}


/*
	Select 2.4/5GHz band
*/
VOID SelectBand6590(
	IN PRTMP_ADAPTER pAd, 
	IN UCHAR Channel)
{
	UCHAR RfValue = 0;
	UINT32 MacValue = 0, IdReg = 0;

	if (!IS_RT6590(pAd))
	{
		DBGPRINT(RT_DEBUG_ERROR, ("%s: Incorrect NIC\n", __FUNCTION__));
		
		return;
	}
	
	DBGPRINT(RT_DEBUG_INFO, ("%s: -->\n", __FUNCTION__));

	if (Channel <= 14) 
	{

		/*
			Select 2.4GHz 
		*/
		for(IdReg = 0; IdReg < RT6590_RF_2G_Channel_0_RegTb_Size; IdReg++)
		{
			rlt_rf_write(pAd, 
						RT6590_RF_2G_Channel_0_RegTb[IdReg].Bank,
						RT6590_RF_2G_Channel_0_RegTb[IdReg].Register,
						RT6590_RF_2G_Channel_0_RegTb[IdReg].Value);
		}		

		rlt_rf_read(pAd, RF_BANK5, RF_R00, &RfValue);
		RfValue &= 0xFE; /* clear 0 = 0 */
		RfValue |= 0x41; /* set bit0 = 1:: 2.4GHz Enable */
		rlt_rf_write(pAd, RF_BANK5, RF_R00, RfValue);

		rlt_rf_read(pAd, RF_BANK6, RF_R00, &RfValue);
		RfValue &= 0xFE; /* clear 0 = 0:: 5GHz Disable */
		rlt_rf_write(pAd, RF_BANK6, RF_R00, RfValue);

		rtmp_mac_set_band(pAd, BAND_24G);

		/* 
			TRSW_EN, RF_TR, LNA_PE_G0 and PA_PE_G0
		*/
		RTMP_IO_WRITE32(pAd, TX_PIN_CFG, 0x00050202); 

	}
	else
	{
		/*
			Select 5GHz 
		*/
		for(IdReg = 0; IdReg < RT6590_RF_5G_Channel_0_RegTb_Size; IdReg++)
		{
			rlt_rf_write(pAd, 
						RT6590_RF_5G_Channel_0_RegTb[IdReg].Bank,
						RT6590_RF_5G_Channel_0_RegTb[IdReg].Register,
						RT6590_RF_5G_Channel_0_RegTb[IdReg].Value);
		}
		
		rlt_rf_read(pAd, RF_BANK5, RF_R00, &RfValue);
		RfValue &= 0xFE; /* clear 0 = 0:: 2.4GHz Disable */
		rlt_rf_write(pAd, RF_BANK5, RF_R00, RfValue);

		rlt_rf_read(pAd, RF_BANK6, RF_R00, &RfValue);
		RfValue &= 0xFE; /* clear 0 = 0 */
		RfValue |= 0x41; /* set bit0 = 1:: 5GHz Enable */
		rlt_rf_write(pAd, RF_BANK6, RF_R00, RfValue);
		
		rtmp_mac_set_band(pAd, BAND_5G);

		/*
			TRSW_EN, RF_TR, LNA_PE_A0 and PA_PE_A0
		*/
		RTMP_IO_WRITE32(pAd, TX_PIN_CFG, 0x00050101);
	}

	
	for(IdReg = 0; IdReg < RT6590_RF_BW_Switch_Size; IdReg++)
	{
		if (pAd->CommonCfg.BBPCurrentBW == RT6590_RF_BW_Switch[IdReg].BW)
		{
			rlt_rf_write(pAd, 
						RT6590_RF_BW_Switch[IdReg].Bank,
						RT6590_RF_BW_Switch[IdReg].Register,
						RT6590_RF_BW_Switch[IdReg].Value);
		}
	}

	DBGPRINT(RT_DEBUG_INFO, ("%s: <--\n", __FUNCTION__));
}

/*
	Set RF channel frequency parameters:	
	Rdiv: R24[1:0]
	N: R29[7:0], R30[0]
	Nominator: R31[4:0]
	Non-Sigma: !SDM R31[7:5]
	Den: (Denomina - 8) R32[4:0]
	Loop Filter Config: R33, R34
	Pll_idiv: frac comp R35[6:0]
*/
VOID SetRfChFreqParameters6590(
	IN PRTMP_ADAPTER pAd, 
	IN UCHAR Channel)
{
	ULONG i = 0;
	UCHAR RFValue = 0, RfBand = 0;

	if (!IS_RT6590(pAd))
	{
		DBGPRINT(RT_DEBUG_ERROR, ("%s: Incorrect NIC\n", __FUNCTION__));		
		return;
	}
	
	DBGPRINT(RT_DEBUG_INFO, ("%s: -->\n", __FUNCTION__));

	for (i = 0; i < NUM_OF_6590_CHNL; i++)
	{
		if (Channel == RT6590_Frequency_Plan[i].Channel)
		{
			RfBand = RT6590_Frequency_Plan[i].Band;			

			/*
				PLL_N: RF register bank 0
				R29[7:0]
				R30[0]				
			*/
			RFValue = RT6590_Frequency_Plan[i].PLL_N & 0x00FF;
			rlt_rf_write(pAd, RF_BANK0, RF_R29, RFValue);

			rlt_rf_read(pAd, RF_BANK0, RF_R30, &RFValue);
			RFValue &= ~(0x1);
			RFValue |= ((RT6590_Frequency_Plan[i].PLL_N >> 8) & 0x0001);
			rlt_rf_write(pAd, RF_BANK0, RF_R30, RFValue);

			/*
				PLL_K (Nominator): 
				R31[4:0] (5-bits)
			*/
			rlt_rf_read(pAd, RF_BANK0, RF_R31, &RFValue);
			RFValue &= ~(0x1F);
			RFValue |= RT6590_Frequency_Plan[i].PLL_K;
			rlt_rf_write(pAd, RF_BANK0, RF_R31, RFValue);
			
			/*
				Rdiv: RF register bank 0
				R24[1:0]
			*/
			rlt_rf_read(pAd, RF_BANK0, RF_R24, &RFValue);
			RFValue &= ~(0x3);
			RFValue |= RT6590_Frequency_Plan[i].Rdiv;
			rlt_rf_write(pAd, RF_BANK0, RF_R24, RFValue);

			/*
				Non-Sigma: !SDM 
				R31[7:5] (3-bits)
			*/
			rlt_rf_read(pAd, RF_BANK0, RF_R31, &RFValue);
			RFValue &= ~(0xE0);
			RFValue |= RT6590_Frequency_Plan[i].NonSigma;
			rlt_rf_write(pAd, RF_BANK0, RF_R31, RFValue);

			/*
				Den: (Denomina - 8) 
				R32[4:0]  (5-bits)
			*/
			rlt_rf_read(pAd, RF_BANK0, RF_R32, &RFValue);
			RFValue &= ~(0x1F);
			RFValue |= RT6590_Frequency_Plan[i].Den;
			rlt_rf_write(pAd, RF_BANK0, RF_R32, RFValue);

			/*
				Loop Filter Config: R33, R34
			*/
			rlt_rf_write(pAd, RF_BANK0, RF_R33, RT6590_Frequency_Plan[i].LFC_R33);
			rlt_rf_write(pAd, RF_BANK0, RF_R34, RT6590_Frequency_Plan[i].LFC_R34);
			
			/*
				Pll_idiv: frac comp 
				R35[6:0]  (7-bits)
			*/
			rlt_rf_read(pAd, RF_BANK0, RF_R35, &RFValue);
			RFValue &= ~(0x7F);
			RFValue |= RT6590_Frequency_Plan[i].Pll_idiv;
			rlt_rf_write(pAd, RF_BANK0, RF_R35, RFValue);			
			
			pAd->LatchRfRegs.Channel = Channel; /* Channel latch */

			DBGPRINT(RT_DEBUG_TRACE,
				("%s: SwitchChannel#%d(Band = 0x%02X, RF=%d, %dT), "
				"PLL_N=0x%02X, PLL_K=0x%02X, Rdiv=0x%02X, NonSigma=0x%02X, Den=0x%02X, R33=0x%02X, R34=0x%02X, Pll_idiv=0x%02X\n",
				__FUNCTION__,
				Channel,
				RfBand,
				pAd->RfIcType,
				pAd->Antenna.field.TxPath,
				RT6590_Frequency_Plan[i].PLL_N,
				RT6590_Frequency_Plan[i].PLL_K,
				RT6590_Frequency_Plan[i].Rdiv,
				RT6590_Frequency_Plan[i].NonSigma,
				RT6590_Frequency_Plan[i].Den,
				RT6590_Frequency_Plan[i].LFC_R33,
				RT6590_Frequency_Plan[i].LFC_R34,
				RT6590_Frequency_Plan[i].Pll_idiv));
			
			break;
		}
	}	

	for(i = 0; i < RT6590_RF_Band_Switch_Size; i++)
	{
		if (RT6590_RF_Band_Switch[i].Band & RfBand)
		{
			rlt_rf_write(pAd, 
						RT6590_RF_Band_Switch[i].Bank,
						RT6590_RF_Band_Switch[i].Register,
						RT6590_RF_Band_Switch[i].Value);
		}
	}
	
	DBGPRINT(RT_DEBUG_INFO, ("%s: <--\n", __FUNCTION__));
}

static VOID NICInitRT6590RFRegisters(RTMP_ADAPTER *pAd)
{

	UINT32 IdReg;
	UCHAR RFValue;

	for(IdReg = 0; IdReg < RT6590_RF_Central_RegTb_Size; IdReg++)
	{
		rlt_rf_write(pAd, 
					RT6590_RF_Central_RegTb[IdReg].Bank,
					RT6590_RF_Central_RegTb[IdReg].Register,
					RT6590_RF_Central_RegTb[IdReg].Value);
	}

	for(IdReg = 0; IdReg < RT6590_RF_2G_Channel_0_RegTb_Size; IdReg++)
	{
		rlt_rf_write(pAd, 
					RT6590_RF_2G_Channel_0_RegTb[IdReg].Bank,
					RT6590_RF_2G_Channel_0_RegTb[IdReg].Register,
					RT6590_RF_2G_Channel_0_RegTb[IdReg].Value);
	}

	for(IdReg = 0; IdReg < RT6590_RF_5G_Channel_0_RegTb_Size; IdReg++)
	{
		rlt_rf_write(pAd, 
					RT6590_RF_5G_Channel_0_RegTb[IdReg].Bank,
					RT6590_RF_5G_Channel_0_RegTb[IdReg].Register,
					RT6590_RF_5G_Channel_0_RegTb[IdReg].Value);
	}

	for(IdReg = 0; IdReg < RT6590_RF_VGA_Channel_0_RegTb_Size; IdReg++)
	{
		rlt_rf_write(pAd, 
					RT6590_RF_VGA_Channel_0_RegTb[IdReg].Bank,
					RT6590_RF_VGA_Channel_0_RegTb[IdReg].Register,
					RT6590_RF_VGA_Channel_0_RegTb[IdReg].Value);
	}
	
	/* 
		vcocal_en (initiate VCO calibration (reset after completion)) - It should be at the end of RF configuration. 
	*/
	rlt_rf_read(pAd, RF_BANK0, RF_R04, &RFValue);
	RFValue = ((RFValue & ~0x80) | 0x80); 
	rlt_rf_write(pAd, RF_BANK0, RF_R04, RFValue);
	return;
}


/*
========================================================================
Routine Description:
	Initialize specific MAC registers.

Arguments:
	pAd					- WLAN control block pointer

Return Value:
	None

Note:
========================================================================
*/
static VOID NICInitRT6590MacRegisters(RTMP_ADAPTER *pAd)
{
	UINT32 IdReg;
	UINT32 MacReg = 0;

	/*
		Enable PBF and MAC clock
		SYS_CTRL[11:10] = 0x3
	*/	
	for(IdReg=0; IdReg<RT6590_NUM_MAC_REG_PARMS; IdReg++)
	{
		RTMP_IO_WRITE32(pAd, RT6590_MACRegTable[IdReg].Register,
								RT6590_MACRegTable[IdReg].Value);
	}
	
	/*
		Release BBP and MAC reset
		MAC_SYS_CTRL[1:0] = 0x0
	*/
	RTMP_IO_READ32(pAd, MAC_SYS_CTRL, &MacReg);
	MacReg &= ~(0x3);
	RTMP_IO_WRITE32(pAd, MAC_SYS_CTRL, MacReg);

	InitTC6008Config(pAd); //2 REMOVE: for test chip only

	InitFce(pAd);
}


/*
========================================================================
Routine Description:
	Initialize specific BBP registers.

Arguments:
	pAd					- WLAN control block pointer

Return Value:
	None

Note:
========================================================================
*/
static VOID NICInitRT6590BbpRegisters(
	IN	PRTMP_ADAPTER pAd)
{

	INT IdReg;

	for(IdReg=0; IdReg < RT6590_BBP_InitRegTb_GBand_Tab_Size; IdReg++)
	{
		RTMP_BBP_IO_WRITE32(pAd, RT6590_BBP_InitRegTb_GBand[IdReg].Register,
				RT6590_BBP_InitRegTb_GBand[IdReg].Value);
	}
	
	return;
}


static VOID RT6590_AsicAntennaDefaultReset(
	IN struct _RTMP_ADAPTER	*pAd,
	IN EEPROM_ANTENNA_STRUC *pAntenna)
{
	pAntenna->word = 0;
	pAntenna->field.RfIcType = 0xf;
	pAntenna->field.TxPath = 2;
	pAntenna->field.RxPath = 2;
}


static VOID RT6590_ChipBBPAdjust(RTMP_ADAPTER *pAd)
{
	static char *ext_str[]={"extNone", "extAbove", "", "extBelow"};
	UCHAR rf_bw, ext_ch;


#ifdef DOT11_N_SUPPORT
	if (get_ht_cent_ch(pAd, &rf_bw, &ext_ch) == FALSE)
#endif /* DOT11_N_SUPPORT */
	{
		rf_bw = BW_20;
		ext_ch = EXTCHA_NONE;
		pAd->CommonCfg.CentralChannel = pAd->CommonCfg.Channel;
	}

#ifdef DOT11_VHT_AC
	if (WMODE_CAP(pAd->CommonCfg.PhyMode, WMODE_AC) &&
		(pAd->CommonCfg.Channel > 14) &&
		(rf_bw == BW_40) &&
		(pAd->CommonCfg.vht_bw == VHT_BW_80) &&
		(pAd->CommonCfg.vht_cent_ch != pAd->CommonCfg.CentralChannel))
	{
		rf_bw = BW_80;
		pAd->CommonCfg.vht_cent_ch = vht_cent_ch_freq(pAd, pAd->CommonCfg.Channel);
	}

//+++Add by shiang for debug
	DBGPRINT(RT_DEBUG_OFF, ("%s():rf_bw=%d, ext_ch=%d, PrimCh=%d, HT-CentCh=%d, VHT-CentCh=%d\n",
				__FUNCTION__, rf_bw, ext_ch, pAd->CommonCfg.Channel,
				pAd->CommonCfg.CentralChannel, pAd->CommonCfg.vht_cent_ch));
//---Add by shiang for debug
#endif /* DOT11_VHT_AC */

	rtmp_bbp_set_bw(pAd, rf_bw);

	/* TX/Rx : control channel setting */
	rtmp_mac_set_ctrlch(pAd, ext_ch);
	rtmp_bbp_set_ctrlch(pAd, ext_ch);
		
#ifdef DOT11_N_SUPPORT
	DBGPRINT(RT_DEBUG_TRACE, ("%s() : %s, ChannelWidth=%d, Channel=%d, ExtChanOffset=%d(%d) \n",
					__FUNCTION__, ext_str[ext_ch],
					pAd->CommonCfg.HtCapability.HtCapInfo.ChannelWidth,
					pAd->CommonCfg.Channel,
					pAd->CommonCfg.RegTransmitSetting.field.EXTCHA,
					pAd->CommonCfg.AddHTInfo.AddHtInfo.ExtChanOffset));
#endif /* DOT11_N_SUPPORT */
}

static VOID RT6590_ChipSwitchChannel(
	struct _RTMP_ADAPTER *pAd,
	UCHAR Channel,
	BOOLEAN	 bScan)
{
	CHAR TxPwer = 0, TxPwer2 = DEFAULT_RF_TX_POWER; /* Bbp94 = BBPR94_DEFAULT, TxPwer2 = DEFAULT_RF_TX_POWER; */
	UINT IdReg;
	UCHAR OldRFValue = 0, RFValue = 0;
	UCHAR PreRFValue;
	UINT32 RegValue = 0;

#ifdef CONFIG_AP_SUPPORT
#ifdef AP_QLOAD_SUPPORT
	/* clear all statistics count for QBSS Load */
	QBSS_LoadStatusClear(pAd);
#endif /* AP_QLOAD_SUPPORT */
#endif /* CONFIG_AP_SUPPORT */

	/*
		Configure 2.4/5GHz before accessing other MAC/BB/RF registers
	*/
	SelectBand6590(pAd, Channel);

	/*
		Set RF channel frequency parameters (Rdiv, N, K, D and Ksd)
	*/
	SetRfChFreqParameters6590(pAd, Channel);

	/* 
		vcocal_en (initiate VCO calibration (reset after completion)) - It should be at the end of RF configuration. 
	*/
	rlt_rf_read(pAd, RF_BANK0, RF_R04, &RFValue);
	RFValue = ((RFValue & ~0x80) | 0x80); 
	rlt_rf_write(pAd, RF_BANK0, RF_R04, RFValue);

	rtmp_bbp_set_bw(pAd, pAd->CommonCfg.BBPCurrentBW);

	/*
		IQ compensation
	*/
	RTMP_BBP_IO_WRITE32(pAd, CAL_R4, 0x000000FF);

	/*
	  On 11A, We should delay and wait RF/BBP to be stable
	  and the appropriate time should be 1000 micro seconds
	  2005/06/05 - On 11G, We also need this delay time. Otherwise it's difficult to pass the WHQL.
	*/
	RTMPusecDelay(1000);	
	return;
}


#ifdef CONFIG_STA_SUPPORT
static VOID RT6590_NetDevNickNameInit(RTMP_ADAPTER *pAd)
{
	snprintf((PSTRING) pAd->nickname, sizeof(pAd->nickname), "RT6590STA");
}
#endif /* CONFIG_STA_SUPPORT */

VOID RT6590_NICInitAsicFromEEPROM(
	IN PRTMP_ADAPTER		pAd)
{
	// TODO: wait TC6008 EEPROM format
}

/*
========================================================================
Routine Description:
	Initialize RT6590.

Arguments:
	pAd					- WLAN control block pointer

Return Value:
	None

Note:
========================================================================
*/
VOID RT6590_Init(RTMP_ADAPTER *pAd)
{
	RTMP_CHIP_OP *pChipOps = &pAd->chipOps;
	RTMP_CHIP_CAP *pChipCap = &pAd->chipCap;
	int idx;


	DBGPRINT(RT_DEBUG_TRACE, ("-->%s():\n", __FUNCTION__));
	
	pAd->RfIcType = RFIC_UNKNOWN;
	/* 
		Init chip capabilities
	*/
	pChipCap->MaxNss = 2;
	pChipCap->TXWISize = 20;
	pChipCap->RXWISize = 28;
	pChipCap->WPDMABurstSIZE = 3;
	
	// TODO: ++++++following parameters are not finialized yet!!
#ifdef RTMP_FLASH_SUPPORT
	pChipCap->eebuf = RT6590_EeBuffer;
#endif /* RTMP_FLASH_SUPPORT */

	pChipCap->SnrFormula = SNR_FORMULA2;
	pChipCap->FlgIsHwWapiSup = TRUE;
	pChipCap->VcoPeriod = 10;
	pChipCap->FlgIsVcoReCalMode = VCO_CAL_MODE_3;
	pChipCap->FlgIsHwAntennaDiversitySup = FALSE;
#ifdef STREAM_MODE_SUPPORT
	pChipCap->FlgHwStreamMode = FALSE;
#endif /* STREAM_MODE_SUPPORT */
#ifdef TXBF_SUPPORT
	pChipCap->FlgHwTxBfCap = FALSE;
#endif /* TXBF_SUPPORT */
#ifdef FIFO_EXT_SUPPORT
	pChipCap->FlgHwFifoExtCap = TRUE;
#endif /* FIFO_EXT_SUPPORT */

#ifdef CONFIG_CSO_SUPPORT
	pChipCap->asic_caps |= fASIC_CAP_CSO;
#endif /* CONFIG_CSO_SUPPORT */
#ifdef CONFIG_TSO_SUPPORT
	pChipCap->asic_caps |= fASIC_CAP_TSO;
#endif /* CONFIG_TSO_SUPPORT */

	pChipCap->asic_caps |= (fASIC_CAP_PMF_ENC);

	pChipCap->phy_caps = (fPHY_CAP_24G | fPHY_CAP_5G);
	pChipCap->phy_caps |= (fPHY_CAP_HT | fPHY_CAP_VHT);

	pChipCap->RfReg17WtMethod = RF_REG_WT_METHOD_STEP_ON;
		
	pChipCap->MaxNumOfRfId = MAX_RF_ID;
	pChipCap->pRFRegTable = NULL;

	pChipCap->MaxNumOfBbpId = 200;	
	pChipCap->pBBPRegTable = NULL;
	pChipCap->bbpRegTbSize = 0;

#ifdef NEW_MBSSID_MODE
	pChipCap->MBSSIDMode = MBSSID_MODE1;
#else
	pChipCap->MBSSIDMode = MBSSID_MODE0;
#endif /* NEW_MBSSID_MODE */


#ifdef CONFIG_STA_SUPPORT
#ifdef RTMP_FREQ_CALIBRATION_SUPPORT
	// TODO: shiang-6590, fix me for FrqCal in STA mode!!
	/* Frequence Calibration */
	pChipCap->FreqCalibrationSupport = FALSE;
	pChipCap->FreqCalInitMode = 0;
	pChipCap->FreqCalMode = 0;
	pChipCap->RxWIFrqOffset = 0;
#endif /* RTMP_FREQ_CALIBRATION_SUPPORT */
#endif /* CONFIG_STA_SUPPORT */

	RTMP_DRS_ALG_INIT(pAd, RATE_ALG_GRP);
		
	/*
		Following function configure beacon related parameters
		in pChipCap
			FlgIsSupSpecBcnBuf / BcnMaxHwNum / 
			WcidHwRsvNum / BcnMaxHwSize / BcnBase[]
	*/
#if 0
#ifdef SPECIFIC_BCN_BUF_SUPPORT
	RtmpChipBcnSpecInit(pAd);
#else
	RtmpChipBcnInit(pAd);
#endif /* SPECIFIC_BCN_BUF_SUPPORT */

	//for (idx = 0; idx < pChipCap->BcnMaxHwNum; idx++)
	//	pChipCap->BcnBase[idx] += 0x4000;

#else
	rlt_bcn_buf_init(pAd);
#endif

	/*
		init operator
	*/

	/* BBP adjust */
	pChipOps->ChipBBPAdjust = RT6590_ChipBBPAdjust;
	
#ifdef CONFIG_STA_SUPPORT
	pChipOps->ChipAGCAdjust = NULL;
#endif /* CONFIG_STA_SUPPORT */

	/* Channel */
	pChipOps->ChipSwitchChannel = RT6590_ChipSwitchChannel;
	pChipOps->ChipAGCInit = NULL;

	pChipOps->AsicMacInit = NICInitRT6590MacRegisters;
	pChipOps->AsicBbpInit = NICInitRT6590BbpRegisters;
	pChipOps->AsicRfInit = NICInitRT6590RFRegisters;
	pChipOps->AsicRfTurnOn = NULL;

	pChipOps->AsicHaltAction = NULL;
	pChipOps->AsicRfTurnOff = NULL;
	pChipOps->AsicReverseRfFromSleepMode = NULL;
	pChipOps->AsicResetBbpAgent = NULL;
	
	/* MAC */

	/* EEPROM */
	pChipOps->NICInitAsicFromEEPROM = RT6590_NICInitAsicFromEEPROM;
	
	/* Antenna */
	pChipOps->AsicAntennaDefaultReset = RT6590_AsicAntennaDefaultReset;

	/* TX ALC */
	pChipOps->InitDesiredTSSITable = NULL;
 	pChipOps->ATETssiCalibration = NULL;
	pChipOps->ATETssiCalibrationExtend = NULL;
	pChipOps->AsicTxAlcGetAutoAgcOffset = NULL;
	pChipOps->ATEReadExternalTSSI = NULL;
	pChipOps->TSSIRatio = NULL;
	
	/* Others */
#ifdef CONFIG_STA_SUPPORT
	pChipOps->NetDevNickNameInit = RT6590_NetDevNickNameInit;
#endif /* CONFIG_STA_SUPPORT */
#ifdef CARRIER_DETECTION_SUPPORT
	pAd->chipCap.carrier_func = TONE_RADAR_V2;
	pChipOps->ToneRadarProgram = ToneRadarProgram_v2;
#endif /* CARRIER_DETECTION_SUPPORT */

	/* Chip tuning */
	pChipOps->RxSensitivityTuning = NULL;
	pChipOps->AsicTxAlcGetAutoAgcOffset = NULL;
	pChipOps->AsicGetTxPowerOffset = NULL;

	
/* Following callback functions already initiailized in RtmpChipOpsEepromHook( ) */
	/*  Calibration access related callback functions */
/*
	int (*eeinit)(struct _RTMP_ADAPTER *pAd);
	int (*eeread)(struct _RTMP_ADAPTER *pAd, USHORT offset, PUSHORT pValue);
	int (*eewrite)(struct _RTMP_ADAPTER *pAd, USHORT offset, USHORT value);
*/
	/* MCU related callback functions */
/*
	int (*loadFirmware)(struct _RTMP_ADAPTER *pAd);
	int (*eraseFirmware)(struct _RTMP_ADAPTER *pAd);
	int (*sendCommandToMcu)(struct _RTMP_ADAPTER *pAd, UCHAR cmd, UCHAR token, UCHAR arg0, UCHAR arg1, BOOLEAN FlgIsNeedLocked);
*/

/* 
	Following callback functions already initiailized in RtmpChipOpsHook() 
	1. Power save related
*/
#ifdef GREENAP_SUPPORT
	pChipOps->EnableAPMIMOPS = NULL;
	pChipOps->DisableAPMIMOPS = NULL;
#endif /* GREENAP_SUPPORT */
	// TODO: ------Upper parameters are not finialized yet!!
}
#endif /* RT65xx */

